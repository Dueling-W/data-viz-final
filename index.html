<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bivariate World Map with Pan and Zoom</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>
<style>
  body { font-family: sans-serif; }
  svg { width: 100%; height: 600px; cursor: grab; }
  .country { stroke: #fff; stroke-width: 0.5px; }
  .legend { display: grid; grid-template-columns: repeat(3, 30px); gap: 2px; margin-top: 10px; }
  .legend div { width: 30px; height: 30px; }
  .tooltip {
    position: absolute; background: rgba(0,0,0,0.8); color: #fff;
    padding: 5px 10px; border-radius: 4px; pointer-events: none; font-size: 12px;
  }
</style>
</head>
<body>

<h2>Bivariate World Map with Pan and Zoom</h2>
<svg></svg>

<div>
  <div>Bivariate Legend:</div>
  <div class="legend" id="legend"></div>
</div>

<div class="tooltip" id="tooltip" style="opacity:0"></div>

<script>
const width = 960;
const height = 600;

const svg = d3.select("svg").attr("width", width).attr("height", height);
const g = svg.append("g");

const projection = d3.geoMercator().scale(150).translate([width/2, height/1.5]);
const path = d3.geoPath().projection(projection);
const tooltip = d3.select("#tooltip");

// Dummy data generator
function generateData() {
  const data = {};
  for (let i = 4; i <= 894; i++) {
    data[i.toString()] = [Math.random().toFixed(2), Math.random().toFixed(2)];
  }
  return data;
}
const data = generateData();

// 3x3 bivariate color scale
const colorScale = d3.scaleOrdinal()
  .domain(["0-0","0-1","0-2","1-0","1-1","1-2","2-0","2-1","2-2"])
  .range(["#e8e8e8","#ace4e4","#5ac8c8","#dfb0d6","#a5add3","#5698b9","#be64ac","#8c62aa","#3b4994"]);

function getBivariateKey(var1, var2) {
  const bin1 = Math.floor(var1 * 3);
  const bin2 = Math.floor(var2 * 3);
  return `${Math.min(bin1,2)}-${Math.min(bin2,2)}`;
}

// Load world TopoJSON
d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(worldData => {

  const countryNames = {};
  worldData.objects.countries.geometries.forEach(d => {
    countryNames[d.id] = d.properties ? d.properties.name : "Unknown";
  });

  const countries = topojson.feature(worldData, worldData.objects.countries).features;
  let active = null;

  const countryPaths = g.selectAll("path")
    .data(countries)
    .enter()
    .append("path")
    .attr("class", "country")
    .attr("d", path)
    .attr("fill", d => {
      const countryData = data[d.id];
      if (!countryData) return "#eee";
      const [var1, var2] = countryData;
      return colorScale(getBivariateKey(var1, var2));
    })
    .on("mouseover", (event, d) => {
      const countryData = data[d.id];
      tooltip.transition().duration(200).style("opacity", 1);
      tooltip.html(`
        <strong>${countryNames[d.id] || "Unknown"}</strong><br>
        <strong>Var1:</strong> ${countryData ? countryData[0] : "N/A"}<br>
        <strong>Var2:</strong> ${countryData ? countryData[1] : "N/A"}
      `)
      .style("left", (event.pageX + 10) + "px")
      .style("top", (event.pageY - 28) + "px");
    })
    .on("mousemove", (event) => {
      tooltip.style("left", (event.pageX + 10) + "px")
             .style("top", (event.pageY - 28) + "px");
    })
    .on("mouseout", () => {
      tooltip.transition().duration(200).style("opacity", 0);
    })
    .on("click", (event, d) => {
      if (active === d) { resetZoom(); active = null; } 
      else { zoomToCountry(d); active = d; }
      event.stopPropagation();
    });

  // Legend
  const legendContainer = d3.select("#legend");
  legendContainer.selectAll("div")
    .data(colorScale.domain())
    .enter()
    .append("div")
    .style("background-color", d => colorScale(d));

  // Zoom behavior (pan + scroll)
  const zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", (event) => { g.attr("transform", event.transform); });

  svg.call(zoom);

  // Enhanced zoom to country
  function zoomToCountry(d) {
  // Get bounding box in pixel space
  const bounds = path.bounds(d);  // [[x0,y0],[x1,y1]]
  const dx = bounds[1][0] - bounds[0][0];
  const dy = bounds[1][1] - bounds[0][1];

  // Add some padding
  const padding = 20;

  // Compute scale to fit width and height inside viewport with padding
  let scale = Math.min(8, 0.9 / Math.max(dx / (width - padding), dy / (height - padding)));

  // Minimum zoom for small countries
  scale = Math.max(scale, 2);

  // Compute projected centroid
  const centroid = d3.geoCentroid(d);
  const [cx, cy] = projection(centroid);

  // Compute translation to center country in viewport
  const translateX = width / 2 - scale * cx;
  const translateY = height / 2 - scale * cy;

  // Smooth zoom
  svg.transition()
     .duration(750)
     .call(
       zoom.transform,
       d3.zoomIdentity
         .translate(translateX, translateY)
         .scale(scale)
     );
}



  // Reset zoom to full world
  function resetZoom() {
    svg.transition()
       .duration(750)
       .call(zoom.transform, d3.zoomIdentity);
  }

  // Click background to reset
  svg.on("click", (event) => {
    if (event.target.tagName === 'svg') { resetZoom(); active = null; }
  });

});
</script>
</body>
</html>
