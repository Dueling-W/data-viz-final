<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bivariate World Map with Pan and Zoom</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/topojson@3"></script>

<style>
  body { font-family: sans-serif; }

  /* NEW: Border around the map */
  #map-container {
    width: 960px;
    height: 600px;
    border: 3px solid black;
    display: inline-block;
  }

  svg { width: 100%; height: 100%; cursor: grab; }

  .country { 
    stroke: #fff; 
    stroke-width: 0.5px; 
    transition: stroke-width 0.15s ease; 
  }

  .legend { 
    display: grid; 
    grid-template-columns: repeat(3, 30px); 
    gap: 2px; 
    margin-top: 10px; 
  }

  .legend div { width: 30px; height: 30px; }

  .tooltip {
    position: absolute;
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 5px 10px;
    border-radius: 4px;
    pointer-events: none;
    font-size: 12px;
  }
</style>
</head>
<body>

<h2>Bivariate World Map with Pan and Zoom</h2>

<!-- NEW: Wrap SVG in a container with a border -->
<div id="map-container">
  <svg></svg>
</div>

<div>
  <div>Bivariate Legend:</div>
  <div class="legend" id="legend"></div>
</div>

<div class="tooltip" id="tooltip" style="opacity:0"></div>

<script>
const width = 960;
const height = 600;

const svg = d3.select("svg").attr("width", width).attr("height", height);
const g = svg.append("g");

const projection = d3.geoMercator().scale(150).translate([width/2, height/1.5]);
const path = d3.geoPath().projection(projection);
const tooltip = d3.select("#tooltip");

// Dummy data
function generateData() {
  const data = {};
  for (let i = 4; i <= 894; i++) {
    data[i.toString()] = [Math.random().toFixed(2), Math.random().toFixed(2)];
  }
  return data;
}
const data = generateData();

// Bivariate color scale
const colorScale = d3.scaleOrdinal()
  .domain(["0-0","0-1","0-2","1-0","1-1","1-2","2-0","2-1","2-2"])
  .range(["#e8e8e8","#ace4e4","#5ac8c8",
          "#dfb0d6","#a5add3","#5698b9",
          "#be64ac","#8c62aa","#3b4994"]);

function getBivariateKey(v1, v2) {
  const bin1 = Math.floor(v1 * 3);
  const bin2 = Math.floor(v2 * 3);
  return `${Math.min(bin1,2)}-${Math.min(bin2,2)}`;
}

d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(worldData => {

  const countryNames = {};
  worldData.objects.countries.geometries.forEach(d => {
    countryNames[d.id] = d.properties ? d.properties.name : "Unknown";
  });

  const countries = topojson.feature(worldData, worldData.objects.countries).features;
  let active = null;

  const countryPaths = g.selectAll("path")
    .data(countries)
    .enter()
    .append("path")
    .attr("class", "country")
    .attr("d", path)
    .attr("fill", d => {
      const vals = data[d.id];
      if (!vals) return "#eee";
      return colorScale(getBivariateKey(vals[0], vals[1]));
    })
    .on("mouseover", function (event, d) {
      const vals = data[d.id];

      tooltip.transition().duration(150).style("opacity", 1);
      tooltip.html(`
        <strong>${countryNames[d.id] || "Unknown"}</strong><br>
        Var1: ${vals ? vals[0] : "N/A"}<br>
        Var2: ${vals ? vals[1] : "N/A"}
      `)
      .style("left", (event.pageX + 10) + "px")
      .style("top", (event.pageY - 28) + "px");

      const [cx, cy] = path.centroid(d);

      d3.select(this)
        .raise()
        .transition().duration(150)
        .style("stroke", "#000")
        .style("stroke-width", 1.2)
        .attr("transform",
          `translate(${cx},${cy}) scale(1.03) translate(${-cx},${-cy})`
        );
    })
    .on("mousemove", (event) => {
      tooltip.style("left", (event.pageX + 10) + "px")
             .style("top", (event.pageY - 28) + "px");
    })
    .on("mouseout", function () {
      tooltip.transition().duration(150).style("opacity", 0);

      d3.select(this)
        .transition().duration(150)
        .style("stroke", "#fff")
        .style("stroke-width", 0.5)
        .attr("transform", null);
    })
    .on("click", (event, d) => {
      if (active === d) { resetZoom(); active = null; }
      else { zoomToCountry(d); active = d; }
      event.stopPropagation();
    });

  d3.select("#legend")
    .selectAll("div")
    .data(colorScale.domain())
    .enter()
    .append("div")
    .style("background-color", d => colorScale(d));

  const zoom = d3.zoom()
    .scaleExtent([1, 8])
    .on("zoom", (event) => { g.attr("transform", event.transform); });

  svg.call(zoom);

  function zoomToCountry(d) {
    const bounds = path.bounds(d);
    const dx = bounds[1][0] - bounds[0][0];
    const dy = bounds[1][1] - bounds[0][1];
    const padding = 20;

    let scale = Math.min(8, 0.9 / Math.max(dx / (width - padding), dy / (height - padding)));
    scale = Math.max(scale, 2);

    const centroid = d3.geoCentroid(d);
    const [cx, cy] = projection(centroid);

    const translateX = width / 2 - scale * cx;
    const translateY = height / 2 - scale * cy;

    svg.transition()
      .duration(750)
      .call(
        zoom.transform,
        d3.zoomIdentity
          .translate(translateX, translateY)
          .scale(scale)
      );
  }

  function resetZoom() {
    svg.transition()
      .duration(750)
      .call(zoom.transform, d3.zoomIdentity);
  }

  svg.on("click", (event) => {
    if (event.target.tagName === 'svg') { resetZoom(); active = null; }
  });

});
</script>
</body>
</html>
