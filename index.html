<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./libs/d3.js"></script>
    <script src="libs/d3jstopojson.v1.js"></script>
    <title>Final Project</title>

    <style>

        .container{
            background-color:azure;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 50px;
        }

        h1 {
            font-family:Arial, Helvetica, sans-serif;
            text-align:center;
        }

        .linecharts {
            display:flex;
            flex-direction: row;
        }


    </style>


</head>




<body>

    <div class="container">
        <div class="worldmap">
            <h1>World Population (2024)</h1>
        </div>
        <div class="worldmap2">
            <h1>Total CO2 Emissions (2023)</h1>
        </div>
        <div class="linecharts">
            <div class=chart1></div>
            <div class="chart2"></div>
        </div>
    </div>


    <script>
        
        let countriesGeo = "data/countries.geojson"
        let populationData = "data/population_data.csv"
        let co2Data = "data/total_co2_data.csv"

        const window_dims = {
            width: window.innerWidth,
            height: window.innerHeight
        };


        const svgWidth = window_dims.width-150;
        const svgHeight = window_dims.height-150;


        Promise.all([d3.json(countriesGeo), d3.csv(populationData), d3.csv(co2Data)], // asynchronous load of both data sources using promise.all()
            d3.autoType())                              // Auto formatting data
            .then(data => {

                let geoJson = data[0]
                let popData = data[1]
                let co2Data = data[2]


                const generateWorldMap = (geoJson,containerName,width,height,margin=30) => {

                    const svg = d3.select(containerName).append("svg")
                        .attr("width", width)
                        .attr("height", height);
                    
                    // create array of 3 character long country codes (i.e. USA)
                    let countries = [];
                    geoJson.features.forEach(d => {countries.push(d.properties["ISO3166-1-Alpha-3"])})
                    
                    let filteredPopData = []
                    popData.forEach(d => {
                        if(countries.includes(d["Country Code"])) {
                            filteredPopData.push(d)
                        }
                    })

                    let popExtent = d3.extent(filteredPopData, (d) => {return +d[2024]})
                    console.log(popExtent)

                    // https://colorbrewer2.org/#type=diverging&scheme=RdBu&n=5
                    const colorInterpolator = d3.interpolateRgbBasis(["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"].reverse())
                    const logScale = d3.scaleLog().domain(popExtent)

                    let projection = d3.geoEquirectangular()
                                        .fitSize([width-margin, height-margin], geoJson)

                    let geoGenerator = d3.geoPath()
                        .projection(d3.geoEquirectangular().fitSize([width-margin,height-margin], geoJson))

                    

                    svg.selectAll("path")
                        .data(geoJson.features)
                        .enter()
                        .append("path")
                        .attr("d", geoGenerator)
                        .attr("fill", d => {
                            try{
                                let currentCode = d.properties["ISO3166-1-Alpha-3"]
                                let countryData = filteredPopData.find(i => i["Country Code"] === currentCode)
                                return colorInterpolator(logScale(countryData[2024]))
                            }
                            catch (error)
                            {
                                // in the case of counties with no data;
                                return "gray";
                            }
                        })


                }
                generateWorldMap(geoJson,".worldmap",svgWidth,svgHeight)

                const generateCO2Map = (geoJson,containerName,width,height,margin=30) => {

                    const svg = d3.select(containerName).append("svg")
                        .attr("width", width)
                        .attr("height", height);
                    
                    // create array of 3 character long country codes (i.e. USA)
                    let countries = [];
                    geoJson.features.forEach(d => {countries.push(d.properties["ISO3166-1-Alpha-3"])})
                    
                    let filteredCO2Data = []
                    co2Data.forEach(d => {
                        if(countries.includes(d["Country Code"])) {
                            filteredCO2Data.push(d)
                        }
                    })

                    let co2Extent = d3.extent(filteredCO2Data, (d) => {return +d[2023]})
                    co2Extent[0] = 1
                    console.log(co2Extent)

                    // https://colorbrewer2.org/#type=diverging&scheme=RdBu&n=5
                    const colorInterpolator = d3.interpolateRgbBasis(["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"].reverse())
                    const logScale = d3.scaleLog().domain(co2Extent)

                    let projection = d3.geoEquirectangular()
                                        .fitSize([width-margin, height-margin], geoJson)

                    let geoGenerator = d3.geoPath()
                        .projection(d3.geoEquirectangular().fitSize([width-margin,height-margin], geoJson))

                    

                    svg.selectAll("path")
                        .data(geoJson.features)
                        .enter()
                        .append("path")
                        .attr("d", geoGenerator)
                        .attr("fill", d => {
                            try{
                                let currentCode = d.properties["ISO3166-1-Alpha-3"]
                                let countryData = filteredCO2Data.find(i => i["Country Code"] === currentCode)
                                
                                // if country has zero emissions
                                if(countryData[2023] == 0) {
                                    return "gray"
                                }

                                return colorInterpolator(logScale(countryData[2023]))
                            }
                            catch (error)
                            {
                                // if geo-country doesn't exist in dataset at all
                                return "gray";
                            }
                        })


                }
                generateCO2Map(geoJson, ".worldmap2", svgWidth, svgHeight)


                const generateLineCharts = (geoJson, width, height, margin=30) => {

                    width = (width/2)-50
                    height = (height)-50

                    const svg1 = d3.select(".chart1").append("svg")
                        .attr("width", width)
                        .attr("height", height);

                    const svg2 = d3.select(".chart2").append("svg")
                        .attr("width", width)
                        .attr("height", height);
                    

                    let filteredPopData = [];
                    popData.forEach(data => {
                        if(data['Country Name'] == "World") {
                            filteredPopData.push(data)
                        }
                    })

                    filteredPopData = filteredPopData[0]
                    console.log(filteredPopData)

                    console.log(Object.keys(filteredPopData))
                    

                    const xYearScale = d3.scaleTime()
                        .domain([new Date('1960', 0, 1), (new Date('2024', 0, 1))])
                        .range([margin, width-margin]);
                    
                    // create four lines
                    const popLine = d3.line()
                        .x(d=> xYearScale(d['date']))
                        .y(d => yScale(d['estimatedCost']))
                        .curve(d3.curveBasis);
                    

                    
                    
                    
                    




                }
                generateLineCharts(geoJson,svgWidth, svgHeight)


                

                






















            })  


    </script>





</body>

</html>

