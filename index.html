<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./libs/d3.js"></script>
    <script src="libs/d3jstopojson.v1.js"></script>
    <title>Final Project - CIS 568</title>

    <style>
        body { font-family: sans-serif; background-color: azure; }

        /* flex container for map + stacked area charts */
        .container {
            display: flex;
            width: 98vw;
        }


        .map-pane {
            flex: 0 0 auto;
            border: none;
        }

        /* sits inside of map-pane */
        #map-container {
            width: 1100px;
            height: 550px;
            border: 3px solid black;
            background-color: white;
        }



        /* charts stack vertically */
        .charts-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
            background: #f7f7f7;
            overflow-y: auto;
        }

        /* container for each chart svg */
        .chart-box {
            flex: 1;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* country outline */
        .country {
            stroke: #fff;
            stroke-width: 0.5px;
            transition: stroke-width 0.15s ease;
        }


        #bottom-row {
            display: flex;
            padding: 5px 15px;
            gap: 30px;
            background: #e9fdff; 
            width:97vw;
        }

        #legend-container {
            position: relative;
            padding-left: 20px;
            padding-top: 20px;
            padding-right:20px;
        }

        /* styling related to the line graphs */
        #country-detail {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #country-title {
            font-weight: bold;
            font-size: 16px;
        }

        #countryName {
            font-weight: normal;
        }

        #country-charts {
            display: flex;
            gap: 20px;
        }

        /* svg formatting for line graphs */
        #countryCo2,
        #countryPop {
            flex: 1;
            height: 200px; 
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
        }



        /* styling for bivariate and stacked area chart legends */
        .bivariate-legend {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(3, 40px);
            gap: 2px;
            position: relative;
        }

        .legend-cell {
            width: 40px;
            height: 40px;
        }

        .legend-axis-label {
            font-size: 12px;
            position: absolute;
            font-weight: bold;
            color: #444;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
        }

        .tooltipLineGraphs {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
        }

        /* title only */
        h1 {
            font-family: sans-serif;
            text-align: center;
            font-weight: bold;
        }

        /* styling for top row (year slider and map title) */
        #year-controls {
            display: grid;
            grid-template-columns: 1fr auto 1fr;  /* left | center | right */
            align-items: center;
            width: 1100px; /* width equal to width of map */
            margin-bottom: 8px;
        }

        #slider-wrap {
            justify-self: start;   /* slider all the way to left */
        }

        #mapTitle {
            justify-self: center;
            font-size: 18px;
            font-weight: bold;
        }


    </style>
</head>

<body>
    <h1>Population and CO₂ Global Comparison</h1>

    <!-- top row of page (year slider and map title)-->
    <div id="year-controls">
        
        <div id="slider-wrap">
            Year: <span id="yearValue">1970</span>
            <input type="range" id="yearSlider" min="1970" max="2024" step="1" value="1970">
        </div>

        <span id="mapTitle">Bivariate CO₂ Per Capita vs. Pop. Density Map</span>

        <div></div>
    </div>

    
    <!-- large container for map + stacked area charts -->
    <div class="container">
        <div class="map-pane">
            <div id="map-container">
                <svg id="map"></svg>
            </div>
        </div>

        <div class="charts-pane">
            <div class="chart-box">
                <svg id="chart1"></svg>
            </div>
            <div class="chart-box">
                <svg id="chart2"></svg>
            </div>
        </div>

    </div>

    <!-- bottom row for bivariate legend, country name, and charts -->
    <div id="bottom-row">
        <div id="legend-container">
            <div id="legend" class="bivariate-legend"></div>
        </div>

        <div id="country-detail">
            <div id="country-title">
                Country Name: <span id="countryName">Click a country on the map</span>
            </div>

            <div id="country-charts">
                <svg id="countryCo2"></svg>
                <svg id="countryPop"></svg>
            </div>
        </div>

    </div>

    <div class="tooltip" id="tooltip" style="opacity:0"></div>

    <div class="tooltipLineGraphs" id="tooltipLineGraphs" style="opacity:0"></div>


    <script>


        let countriesGeo = "data/countries.geojson"; // geo data
        let populationData = "data/population_density_data.csv";
        let co2Data = "data/co2_capita_data.csv";
        let continentMap = "data/continentMap.json"; // json mapping countries to continents
        let totalCO2Data = "data/total_co2_data.csv";
        let totalPopData = "data/population_data.csv"

        // width and height of only the map 
        const container = document.getElementById("map-container");
        const width = container.clientWidth;
        const height = container.clientHeight;

        // set initial sizes for co2 and pop line graphs due to weird bug (charts growing...)
        const co2Svg = d3.select("#countryCo2");
        const popSvg = d3.select("#countryPop");

        const co2Box = co2Svg.node().getBoundingClientRect();
        const popBox = popSvg.node().getBoundingClientRect();


        const svg = d3.select("#map")
            .attr("width", width)
            .attr("height", height);

        const g = svg.append("g");

        Promise.all([
            d3.json(countriesGeo),
            d3.csv(populationData),
            d3.csv(co2Data),
            d3.json(continentMap),
            d3.csv(totalCO2Data),
            d3.csv(totalPopData)
        ],
        d3.autoType())
        .then(data => {
            let geoJson = data[0];
            let popData = data[1];
            let co2Data = data[2];
            let continentMapData = data[3]; 
            let totalCO2Data = data[4];   
            let totalPopData = data[5]


            // based on a given country code, return co2 and pop data for all valid years 
            // 3-digit country code used, i.e., USA
            function getCountrySeries(countryCode) {
                const popRow = popData.find(d => d["Country Code"] === countryCode);
                const co2Row = co2Data.find(d => d["Country Code"] === countryCode);

                if (!popRow && !co2Row) return null; // if no data for country

                const years = availableYears.map(y => +y);

                const popSeries = years.map(y => {
                    const col = String(y);
                    const v = popRow ? +popRow[col] : NaN;
                    return isNaN(v) ? null : v; // array of integers (population)
                });

                const co2Series = years.map(y => {
                    const col = String(y);
                    const v = co2Row ? +co2Row[col] : NaN;
                    return isNaN(v) ? null : v; // array of integers (co2)
                });

                // return array of years, pop, co2, along with original rows from .csv file
                return { years, popSeries, co2Series, popRow, co2Row };
            }



            // actually draw the charts
            function updateCountryDetail(countryName, series, co2Box, popBox) {
                const { years, co2Series, popSeries } = series;

                d3.select("#countryName").text(countryName);
                const tooltip = d3.select("#tooltipLineGraphs");


                // sets up SVG with proper sizes from the co2Box and popBox objects
                const co2Svg = d3.select("#countryCo2");
                const popSvg = d3.select("#countryPop");

                const co2Width  = co2Box.width  || 300;
                const co2Height = co2Box.height || 200;
                const popWidth  = popBox.width  || 300;
                const popHeight = popBox.height || 200;

                const margin = { top: 25, right: 15, bottom: 30, left: 45 };

                const innerCo2Width  = co2Width  - margin.left - margin.right;
                const innerCo2Height = co2Height - margin.top  - margin.bottom;
                const innerPopWidth  = popWidth  - margin.left - margin.right;
                const innerPopHeight = popHeight - margin.top  - margin.bottom;

                co2Svg.attr("width",  co2Width).attr("height", co2Height);
                popSvg.attr("width",  popWidth).attr("height", popHeight);

                // clear previous drawings (probably not necessary but just in-case)
                co2Svg.selectAll("*").remove();
                popSvg.selectAll("*").remove();




                const co2G = co2Svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                const popG = popSvg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // labeling for the co2 svg
                // yes i know the x and y values are really weird i just played with them until they worked
                co2Svg.append("text")
                    .attr("class", "y-axis-label")
                    .attr("x", -co2Height+100) 
                    .attr("y", 11)
                    .attr("transform", "rotate(-90)")
                    .attr("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("CO₂ per capita");

                co2Svg.append("text")
                    .attr("class", "x-axis-label")
                    .attr("x", co2Width/2)
                    .attr("y", co2Height-6)
                    .attr("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("Year");

                // labeling for the pop svg
                popSvg.append("text")
                    .attr("class", "y-axis-label")
                    .attr("x", -co2Height+100)
                    .attr("y", 11)
                    .attr("transform", "rotate(-90)")
                    .attr("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("Population density");

                popSvg.append("text")
                    .attr("class", "x-axis-label")
                    .attr("x", co2Width/2)
                    .attr("y", co2Height-6)
                    .attr("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("Year");

                // skips all null values in the series
                const co2DataSeries = years.map((y, i) => ({ Year: y, value: co2Series[i] }))
                    .filter(d => d.value != null);

                const popDataSeries = years.map((y, i) => ({ Year: y, value: popSeries[i] }))
                    .filter(d => d.value != null);

                // only triggered if no data is available at all
                if (co2DataSeries.length === 0) {
                    co2G.append("text")
                        .attr("x", innerCo2Width / 2)
                        .attr("y", innerCo2Height / 2)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .text("No CO₂ data available");
                }

                if (popDataSeries.length === 0) {
                    popG.append("text")
                        .attr("x", innerPopWidth / 2)
                        .attr("y", innerPopHeight / 2)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .text("No population data available");
                }


                // year scalers for co2/pop
                const xCo2 = d3.scaleLinear()
                    .domain(d3.extent(years))
                    .range([0, innerCo2Width]);

                // pop scaler
                const xPop = d3.scaleLinear()
                    .domain(d3.extent(years))
                    .range([0, innerPopWidth]);

                //co2 scaler
                const yCo2 = d3.scaleLinear()
                    .domain([0, d3.max(co2DataSeries, d => d.value) || 0])
                    .nice()
                    .range([innerCo2Height, 0]);

                // pop scaler 
                const yPop = d3.scaleLinear()
                    .domain([0, d3.max(popDataSeries, d => d.value) || 0])
                    .nice()
                    .range([innerPopHeight, 0]);

                // draw the lines
                const co2Line = d3.line()
                    .defined(d => d.value != null)  // skip gaps
                    .x(d => xCo2(d.Year))
                    .y(d => yCo2(d.value));

                const popLine = d3.line()
                    .defined(d => d.value != null)
                    .x(d => xPop(d.Year))
                    .y(d => yPop(d.value));



                // co2 chart axes, line, and title
                co2G.append("g")
                    .attr("transform", `translate(0,${innerCo2Height})`)
                    .call(d3.axisBottom(xCo2).tickFormat(d3.format("d")).ticks(5));

                co2G.append("g")
                    .call(d3.axisLeft(yCo2));

                const bisectYear = d3.bisector(d => d.Year).left;   // data sorted by Year!

                if (co2DataSeries.length > 0) {
                    co2G.append("path")
                        .datum(co2DataSeries)
                        .attr("fill", "none")
                        .attr("stroke", "#1f77b4")
                        .attr("stroke-width", 7)
                        .attr("d", co2Line)
                        .on("mousemove", function (event, dataArray) {     // dataArray is the full array
                            // get current mouse x/y
                            const [mx, my] = d3.pointer(event, this);

                            // convert pixels into an x-value using our x-scale
                            // wont be a whole number (something like 2013.1 for example)
                            const x0 = xCo2.invert(mx);


                            // place the x0 in the array and get the index
                            let i = bisectYear(dataArray, x0, 1);
                            if (i >= dataArray.length) i = dataArray.length - 1; // account for index being at the end of the array
                            const d0 = dataArray[i - 1]; // point to left
                            const d1 = dataArray[i]; // point to right
                            const point = (x0 - d0.Year > d1.Year - x0) ? d1 : d0; // compute which datapoint is closer (i.e., 2013.1 is closer to 2013 than 2014)

                            // simply get year and value from this point
                            const year  = point.Year;
                            const value = point.value;

                            const fmt3 = d3.format(",.3f"); // format to 3 decimal points

                            tooltip
                                .style("opacity", 1)
                                .html(`
                                Year: ${year}<br>
                                CO2 per capita: ${fmt3(value)}
                                `)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top",  (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function () {
                            tooltip.transition().duration(150).style("opacity", 0);
                        });
                }

                co2G.append("text")
                    .attr("x", innerCo2Width / 2)
                    .attr("y", -8)
                    .attr("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("font-weight", "bold")
                    .text("CO₂ per Capita Line Graph");



                // pop chart axes, line, and title
                popG.append("g")
                    .attr("transform", `translate(0,${innerPopHeight})`)
                    .call(d3.axisBottom(xPop).tickFormat(d3.format("d")).ticks(5));

                popG.append("g")
                    .call(d3.axisLeft(yPop));

                if (popDataSeries.length > 0) {
                    popG.append("path")
                        .datum(popDataSeries)
                        .attr("fill", "none")
                        .attr("stroke", "#2ca02c")
                        .attr("stroke-width", 7)
                        .attr("d", popLine)
                        .on("mousemove", function (event, dataArray) {     // dataArray is the full array
                            // get current mouse x/y
                            const [mx, my] = d3.pointer(event, this);

                            // convert pixels into an x-value using our x-scale
                            // wont be a whole number (something like 2013.1 for example)
                            const x0 = xPop.invert(mx);


                            // place the x0 in the array and get the index
                            let i = bisectYear(dataArray, x0, 1);
                            if (i >= dataArray.length) i = dataArray.length - 1; // account for index being at the end of the array
                            const d0 = dataArray[i - 1]; // point to left
                            const d1 = dataArray[i]; // point to right
                            const point = (x0 - d0.Year > d1.Year - x0) ? d1 : d0; // compute which datapoint is closer (i.e., 2013.1 is closer to 2013 than 2014)

                            // simply get year and value from this point
                            const year  = point.Year;
                            const value = point.value;

                            const fmt3 = d3.format(",.3f"); // format to 3 decimal points

                            // small bug fix to account for right side of the screen
                            let offset = 0;
                            if(year >= 2010) {
                                offset = 237
                            }

                            tooltip
                                .style("opacity", 1)
                                .html(`
                                Year: ${year}<br>
                                Population Density: ${fmt3(value)}
                                `)
                                .style("left", (event.pageX + 10-offset) + "px")
                                .style("top",  (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function () {
                            tooltip.transition().duration(150).style("opacity", 0);
                        });
                }

                popG.append("text")
                    .attr("x", innerPopWidth / 2)
                    .attr("y", -8)
                    .attr("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("font-weight", "bold")
                    .text("Population Density Line Graph");
            }



            // select years from column
            const popYearCols = popData.columns.filter(c => /^\d{4}$/.test(c));
            const co2YearCols = co2Data.columns.filter(c => /^\d{4}$/.test(c));


            var availableYears = popYearCols.filter(y => co2YearCols.includes(y));
            availableYears = availableYears.filter(item => item !== "2024"); // no data in 2024 despite column existing

            // filter years in the 60s since co2 data has all null values in those years
            availableYears = availableYears.filter(item => !item.startsWith("196"));

            console.log(availableYears);

            const minYear = d3.min(availableYears, d => +d);
            const maxYear = d3.max(availableYears, d => +d);
            let selectedYear = String(minYear);

            // set initial values and text for the selected year
            const yearSlider = d3.select("#yearSlider")
                .attr("min", minYear)
                .attr("max", maxYear)
                .attr("value", selectedYear);

            const yearLabel = d3.select("#yearValue")
                .text(selectedYear);









            // bivariate world map

            const generateWorldMap = (geoJson, containerName, width, height, margin = 30) => {
                // clear previous map and legend
                g.selectAll("*").remove();
                d3.select("#legend").selectAll("*").remove();


                // computes quantiles using a log scale for the current year's values
                const co2Vals = co2Data
                    .map(d => +d[selectedYear])
                    .filter(v => !isNaN(v));

                const co2Quant = d3.scaleQuantile()
                    .domain(co2Vals.map(v => Math.log10(v + 1)))
                    .range([0, 1, 2]);

                const popVals = popData
                    .map(d => +d[selectedYear])
                    .filter(v => !isNaN(v));

                const popQuant = d3.scaleQuantile()
                    .domain(popVals.map(v => Math.log10(v + 1)))
                    .range([0, 1, 2]);


                // maps to a specific bivariate point like (1, 2) based on co2/pop values
                function getBivariateKey(co2, pop) {
                    if (co2 == null || pop == null || isNaN(co2) || isNaN(pop)) {
                        return null;
                    }
                    const bin1 = co2Quant(Math.log10(co2 + 1));
                    const bin2 = popQuant(Math.log10(pop + 1));
                    return `${bin1}-${bin2}`;
                }

                console.log("Using year:", selectedYear);
                console.log("pop domain:", popQuant.domain());
                console.log("pop quantiles:", popQuant.quantiles());

                let active = null;

                // list all countries in geoJson dataset by three digit code
                let countries = [];
                geoJson.features.forEach(d => { countries.push(d.properties["ISO3166-1-Alpha-3"]); });

                // filter pop and co2 data to only include countries that exist in the geo dataset

                let filteredPopData = [];
                popData.forEach(d => {
                    if (countries.includes(d["Country Code"])) {
                        filteredPopData.push(d);
                    }
                });

                let filteredCO2Data = [];
                co2Data.forEach(d => {
                    if (countries.includes(d["Country Code"])) {
                        filteredCO2Data.push(d);
                    }
                });


                // maps each value in the domain to a distinct color
                // values are x-y pairs of squares on the 3x3 bivariate grid
                const colorScale = d3.scaleOrdinal()
                    .domain(["0-0", "0-1", "0-2", "1-0", "1-1", "1-2", "2-0", "2-1", "2-2"])
                    .range([
                        "#e8e8e8", "#ace4e4", "#5ac8c8",
                        "#dfb0d6", "#a5add3", "#5698b9",
                        "#be64ac", "#8c62aa", "#3b4994"
                    ]);



                const projection = d3.geoMercator().scale(145).translate([width / 2, height / 2 +85]); // 85 offset just removes antartica basically
                const path = d3.geoPath().projection(projection);
                const tooltip = d3.select("#tooltip");


                
                g.selectAll("path")
                    .data(geoJson.features)
                    .enter()
                    .append("path")
                    .attr("class", "country")
                    .attr("d", path)
                    .attr("fill", d => {
                        try {
                            let currentCode = d.properties["ISO3166-1-Alpha-3"];
                            let allPopData = filteredPopData.find(i => i["Country Code"] === currentCode);
                            let popVal = allPopData[selectedYear];

                            let allCO2Data = filteredCO2Data.find(i => i["Country Code"] === currentCode);
                            let co2Val = allCO2Data[selectedYear];

                            return colorScale(getBivariateKey(+co2Val, +popVal));
                        } catch (error) {
                            return "gray"; // fallback to gray coloring
                        }
                    })
                    .on("mouseover", function (event, d) {
                        let currentCode = d.properties["ISO3166-1-Alpha-3"];
                        let allPopData = filteredPopData.find(i => i["Country Code"] === currentCode);
                        let popVal = allPopData ? allPopData[selectedYear] : null;

                        let allCO2Data = filteredCO2Data.find(i => i["Country Code"] === currentCode);
                        let co2Val = allCO2Data ? allCO2Data[selectedYear] : null;

                        const fmt3 = d3.format(",.3f"); // format to 3 decimal points

                        // square tooltip for countries
                        tooltip.transition().duration(150).style("opacity", 1);
                        tooltip.html(`
                            <strong>${d.properties.name || "Unknown"}</strong><br>
                            Population Density (${selectedYear}): ${popVal ? fmt3(popVal) : "N/A"}<br>
                            CO₂ per Capita (${selectedYear}): ${co2Val ? fmt3(co2Val) : "N/A"}
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");

                        const [cx, cy] = path.centroid(d);

                        // slightly raises and changes the outline when country is hovered
                        d3.select(this)
                            .raise()
                            .transition().duration(150)
                            .style("stroke", "#000")
                            .style("stroke-width", 1.2)
                            .attr("transform",
                                `translate(${cx},${cy}) scale(1.03) translate(${-cx},${-cy})`
                            );
                    })
                    .on("mousemove", (event) => {
                        // just updates the tooltip's position
                        tooltip.style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function () {
                        // transition out and lower (un-raise??) the country
                        tooltip.transition().duration(150).style("opacity", 0);

                        d3.select(this)
                            .transition().duration(150)
                            .style("stroke", "#fff")
                            .style("stroke-width", 0.5)
                            .attr("transform", null);
                    })
                    .on("click", (event, d) => {

                        // clear the co2 and svg line graphs, reset country name to default
                        const co2Svg = d3.select("#countryCo2");
                        const popSvg = d3.select("#countryPop");
                        co2Svg.selectAll("*").remove();
                        popSvg.selectAll("*").remove();

                        d3.select("#countryName").text("Click a country on the map")

                        // only true if you are currently zoomed into a country
                        if (active === d) { 
                            // so reset back to overall view
                            resetZoom(); 
                            active = null; 
                        }
                        else { 
                            zoomToCountry(d);
                            active = d; 

                            // get the name of the current country, update line graphs accordingly
                            let countryCode = d.properties["ISO3166-1-Alpha-3"];
                            let series = getCountrySeries(countryCode)
                            let countryName = series.co2Row['Country Name'];
                            updateCountryDetail(countryName, series, co2Box, popBox);
                        }
                        event.stopPropagation();
                    });
                


                // 3x3 legend
                const legendData = [
                    ["0-2", "1-2", "2-2"],
                    ["0-1", "1-1", "2-1"],
                    ["0-0", "1-0", "2-0"]
                ];

                const legend = d3.select("#legend");

                legend
                    .selectAll(".legend-cell")
                    .data(legendData.flat())
                    .enter()
                    .append("div")
                    .attr("class", "legend-cell")
                    .style("background-color", d => colorScale(d)); // color the square based on its value ex: (2,2) is blue
                
                legend.append("div")
                    .attr("class", "legend-axis-label")
                    .style("left", "0px")
                    .style("top", "125px")
                    .text("Higher CO₂ per capita →");

                legend.append("div")
                    .attr("class", "legend-axis-label")
                    .style("position", "absolute")
                    .style("left", "-76px")
                    .style("top", "50px")
                    .style("transform", "rotate(-90deg)")
                    .text("Higher pop. density →");
                
                // simple zoom + pan
                const zoom = d3.zoom()
                    .scaleExtent([1, 8])
                    .on("zoom", (event) => { g.attr("transform", event.transform); });

                svg.call(zoom);

                // zooms into the country
                function zoomToCountry(d) {
                    const bounds = path.bounds(d); // bounds of country from geoData
                    const dx = bounds[1][0] - bounds[0][0];
                    const dy = bounds[1][1] - bounds[0][1];
                    const padding = 20;

                    let scale = Math.min(8, 0.9 / Math.max(dx / (width - padding), dy / (height - padding)));
                    scale = Math.max(scale, 2);

                    const centroid = d3.geoCentroid(d);
                    const [cx, cy] = projection(centroid);

                    const translateX = width / 2 - scale * cx;
                    const translateY = height / 2 - scale * cy;

                    svg.call(
                        zoom.transform,
                        d3.zoomIdentity
                            .translate(translateX, translateY)
                            .scale(scale)
                    );
                }

                function resetZoom() {
                    svg.call(zoom.transform, d3.zoomIdentity);
                }


                // if the user clicks on the svg BUT not a country, still need to reset the zoom and clear the charts
                svg.on("click", (event) => {
                    if (event.target.tagName === 'svg') { 
                        resetZoom(); 
                        active = null;

                        const co2Svg = d3.select("#countryCo2");
                        const popSvg = d3.select("#countryPop");
                        co2Svg.selectAll("*").remove();
                        popSvg.selectAll("*").remove();

                        d3.select("#countryName").text("Click a country on the map")

                    }
                });
            };

            generateWorldMap(geoJson, "#map", width, height);



            yearSlider.on("input", function () {
                selectedYear = this.value;
                yearLabel.text(selectedYear);
            });

            // make sure to only update the map once the user stops dragging, otherwise it is extremely laggy
            yearSlider.on("change", function () {
                selectedYear = this.value;
                yearLabel.text(selectedYear);
                generateWorldMap(geoJson, "#map", width, height);
            });






            
            // co2 area chart
            const generateCO2Map = (continentMap, totalCO2Data) => {
                const svgChart = d3.select("#chart1");

                svgChart.selectAll("*").remove();

                // get true size from the doc element
                const chartBox = document.getElementById("chart1").parentNode;
                const svgWidth  = chartBox.clientWidth  || 400;
                const svgHeight = chartBox.clientHeight || 250;

                svgChart
                    .attr("width", svgWidth)
                    .attr("height", svgHeight);

                // margins and define inner width
                const margin = { top: 40, right: 130, bottom: 40, left: 70 },
                      innerWidth  = svgWidth  - margin.left - margin.right,
                      innerHeight = svgHeight - margin.top  - margin.bottom;

                const gChart = svgChart.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const tooltip = d3.select(".tooltip");

                const years = totalCO2Data.columns.slice(4); // first four values are not actually years

                
                const continentAgg = {};
                totalCO2Data.forEach(d => {
                    const continent = continentMap[d["Country Name"]];
                    if (!continent) return;
                    if (!continentAgg[continent]) continentAgg[continent] = {}; // initialize continent bucket when first encountered
                    years.forEach(y => {
                        const val = parseFloat(d[y]); // get co2 data for the current year
                        if (!isNaN(val)) {
                            continentAgg[continent][y] = (continentAgg[continent][y] || 0) + val; // simply sum the values (fallback is 0)
                        }
                    });
                });

                // convert to a stacked array where each element is a year with continent values
                const stackedArray = years.map(y => {
                    const row = { Year: +y }; // first element is the year
                    Object.keys(continentAgg).forEach(c => {
                        const val = continentAgg[c][y];
                        if (val !== undefined) row[c] = val; // add value for that continent to current row
                    });
                    return row;
                }).filter(d => Object.keys(d).length > 1); // only include years that have continent values


                const continents = Object.keys(continentAgg); // just the name of the continents

                const stack = d3.stack().keys(continents);
                const series = stack(stackedArray);

               // scale for X and Y axes
                const x = d3.scaleLinear()
                    .domain(d3.extent(stackedArray, d => d.Year))
                    .range([0, innerWidth]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(series, s => d3.max(s, d => d[1]))])
                    .range([innerHeight, 0]);

                // maps each continent to their own color
                const color = d3.scaleOrdinal(d3.schemeCategory10)
                    .domain(continents);

                
                const area = d3.area()
                    .x(d => x(d.data.Year))
                    .y0(d => y(d[0]))
                    .y1(d => y(d[1]));

                // layer the area charts on top of each other
                const layers = gChart.selectAll(".layer")
                    .data(series)
                    .join("path")
                    .attr("class", "layer")
                    .attr("d", area)
                    .attr("fill", d => color(d.key))
                    .on("mouseover", function (event, d) {
                        // changes opacity of hovered continent and other continents
                        layers.attr("opacity", 0.2);
                        d3.select(this).attr("opacity", 1).raise();
                        tooltip.style("opacity", 1);
                    })
                    .on("mousemove", function (event, d) {
                        const xm = d3.pointer(event, this)[0];
                        const year = Math.round(x.invert(xm));
                        const row = stackedArray.find(r => r.Year === year);
                        if (row && row[d.key] !== undefined) {
                            tooltip
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 25) + "px")
                                .html(`<strong>${d.key}</strong><br>Year: ${year}<br>CO₂: ${row[d.key].toFixed(2)} Mt`);
                        }
                    })
                    .on("mouseout", function () {
                        // resets layers to full opacity, clears tooltip
                        layers.attr("opacity", 1);
                        tooltip.style("opacity", 0);
                    });


                // create the axes, axes labels, and chart title
                gChart.append("g")
                    .attr("transform", `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(x).tickFormat(d3.format("d")));

                gChart.append("g")
                    .call(d3.axisLeft(y));

                svgChart.append("text")
                    .attr("class", "chart-title")
                    .attr("x", svgWidth / 2)
                    .attr("y", margin.top / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("font-weight", "bold")
                    .text("Global CO₂ Emissions by Continent");

                gChart.append("text")
                    .attr("class", "y-axis-label")
                    .attr("x", -height/5)
                    .attr("y", -45)
                    .attr("transform", "rotate(-90)")
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("CO₂ Emissions");

                gChart.append("text")
                    .attr("class", "x-axis-label")
                    .attr("x", width/4+3)
                    .attr("y", 213)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Year");


                // legend that displays to the right of the chart
                const legend = svgChart.append("g")
                    .attr("transform", `translate(${margin.left + innerWidth + 15},${margin.top})`);

                continents.forEach((c, i) => {
                    const gLegend = legend.append("g")
                        .attr("transform", `translate(0,${i * 18})`);

                    gLegend.append("rect")
                        .attr("width", 14)
                        .attr("height", 14)
                        .attr("fill", color(c));

                    gLegend.append("text")
                        .attr("x", 20)
                        .attr("y", 11)
                        .attr("font-size", 13)
                        .text(c);
                });
            };

            // draw stacked CO2 chart once
            generateCO2Map(continentMapData, totalCO2Data);




            // stacked population area chart in the #chart2 svg
            // essentially identical to CO2 map
            const generatePopMap = (continentMap, totalPopData) => {
                const svgChart = d3.select("#chart2");

                svgChart.selectAll("*").remove();

                const chartBox = document.getElementById("chart2").parentNode;
                const svgWidth  = chartBox.clientWidth  || 400;
                const svgHeight = chartBox.clientHeight || 250;

                svgChart
                    .attr("width", svgWidth)
                    .attr("height", svgHeight);

                const margin = { top: 40, right: 130, bottom: 40, left: 70 },
                    innerWidth  = svgWidth  - margin.left - margin.right,
                    innerHeight = svgHeight - margin.top  - margin.bottom;

                const gChart = svgChart.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const tooltip = d3.select(".tooltip");

                const years = totalPopData.columns.slice(4);  // assumes same structure as CO2 CSV

                const continentAgg = {};
                totalPopData.forEach(d => {
                    const continent = continentMap[d["Country Name"]];
                    if (!continent) return;
                    if (!continentAgg[continent]) continentAgg[continent] = {};
                    years.forEach(y => {
                        const val = parseFloat(d[y]);
                        if (!isNaN(val)) {
                            continentAgg[continent][y] = (continentAgg[continent][y] || 0) + val;
                        }
                    });
                });

                const stackedArray = years.map(y => {
                    const row = { Year: +y };
                    Object.keys(continentAgg).forEach(c => {
                        const val = continentAgg[c][y];
                        if (val !== undefined) row[c] = val;
                    });
                    return row;
                }).filter(d => Object.keys(d).length > 1);

                const continents = Object.keys(continentAgg);

                const stack = d3.stack().keys(continents);
                const series = stack(stackedArray);

                const x = d3.scaleLinear()
                    .domain(d3.extent(stackedArray, d => d.Year))
                    .range([0, innerWidth]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(series, s => d3.max(s, d => d[1]))])
                    .range([innerHeight, 0]);

                const color = d3.scaleOrdinal(d3.schemeCategory10)
                    .domain(continents);

                const area = d3.area()
                    .x(d => x(d.data.Year))
                    .y0(d => y(d[0]))
                    .y1(d => y(d[1]));

                const layers = gChart.selectAll(".layer")
                    .data(series)
                    .join("path")
                    .attr("class", "layer")
                    .attr("d", area)
                    .attr("fill", d => color(d.key))
                    .on("mouseover", function (event, d) {
                        layers.attr("opacity", 0.2);
                        d3.select(this).attr("opacity", 1).raise();
                        tooltip.style("opacity", 1);
                    })
                    .on("mousemove", function (event, d) {
                        const xm = d3.pointer(event, this)[0];
                        const year = Math.round(x.invert(xm));
                        const row = stackedArray.find(r => r.Year === year);
                        if (row && row[d.key] !== undefined) {
                            tooltip
                                .style("left", (event.pageX + 10) + "px")
                                .style("top",  (event.pageY - 25) + "px")
                                .html(
                                    `<strong>${d.key}</strong><br>` +
                                    `Year: ${year}<br>` +
                                    `Population: ${d3.format(",")(row[d.key])}`
                                );
                        }
                    })
                    .on("mouseout", function () {
                        layers.attr("opacity", 1);
                        tooltip.style("opacity", 0);
                    });


                svgChart.append("text")
                    .attr("class", "chart-title")
                    .attr("x", svgWidth / 2)
                    .attr("y", margin.top / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("font-weight", "bold")
                    .text("Global Population by Continent");
                
                gChart.append("g")
                    .attr("transform", `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(x).tickFormat(d3.format("d")));

                gChart.append("g")
                    .call(d3.axisLeft(y).tickFormat(d3.format(".2s"))); // compact numbering in scientifc notation 1M, 10M, etc.
                
                
                gChart.append("text")
                    .attr("class", "y-axis-label")
                    .attr("x", -height/5)
                    .attr("y", -45)
                    .attr("transform", "rotate(-90)")
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Population");

                gChart.append("text")
                    .attr("class", "x-axis-label")
                    .attr("x", width/4+3)
                    .attr("y", 213)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Year");

                const legend = svgChart.append("g")
                    .attr("transform", `translate(${margin.left + innerWidth + 15},${margin.top})`);

                continents.forEach((c, i) => {
                    const gLegend = legend.append("g")
                        .attr("transform", `translate(0,${i * 18})`);

                    gLegend.append("rect")
                        .attr("width", 14)
                        .attr("height", 14)
                        .attr("fill", color(c));

                    gLegend.append("text")
                        .attr("x", 20)
                        .attr("y", 11)
                        .attr("font-size", 13)
                        .text(c);
                });
            };


            generatePopMap(continentMapData, totalPopData);

        });
    </script>
</body>
</html>
