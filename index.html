<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./libs/d3.js"></script>
    <script src="libs/d3jstopojson.v1.js"></script>
    <title>Final Project</title>

    <style>
        body { font-family: sans-serif; 
                background-color: azure;
        }

        /* Main horizontal layout: left = map, right = charts */
        .container {
            display: flex;
            width: 98vw;
        }

        #map-container {
            width: 1100px;
            height: 550px;
            border: 3px solid black;
            background-color: white;
        }

        .map-pane {
            flex: 0 0 auto;
            border: none;
        }

        /* Charts stack vertically */
        .charts-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 10px;
            background: #f7f7f7;
            overflow-y: auto;
        }

        /* Chart containers */
        .chart-box {
            flex: 1;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .country {
            stroke: #fff;
            stroke-width: 0.5px;
            transition: stroke-width 0.15s ease;
        }

        #bottom-row {
            display: flex;
            padding: 10px 20px;
            gap: 30px;
            background: #e9fdff;   /* same light blue as your page, or tweak */
            width:97vw;
        }

        #legend-container {
            position: relative;
            padding-left: 20px;
            padding-top: 20px;
            padding-right:20px;
        }

        /* NEW country detail area */
        #country-detail {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #country-title {
            font-weight: bold;
            font-size: 16px;
        }

        #countryName {
            font-weight: normal;
        }

        #country-charts {
            display: flex;
            gap: 20px;
        }

        /* The two small line-chart svgs */
        #countryCo2,
        #countryPop {
            flex: 1;
            height: 200px;    /* you can tweak this */
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
        }

        .bivariate-legend {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            grid-template-rows: repeat(3, 40px);
            gap: 2px;
            position: relative;
        }

        .legend-cell {
            width: 40px;
            height: 40px;
        }

        .legend-axis-label {
            font-size: 12px;
            position: absolute;
            font-weight: bold;
            color: #444;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
        }

        h1 {
            font-family: sans-serif;
            text-align: center;
            font-weight: bold;
        }

        #year-controls {
            display: grid;
            grid-template-columns: 1fr auto 1fr;  /* left | center | right */
            align-items: center;
            width: 1100px;
            margin-bottom: 8px;
        }

        #slider-wrap {
            justify-self: start;   /* lock slider to the left */
        }

        #mapTitle {
            justify-self: center;  /* true centering */
            font-size: 18px;
            font-weight: bold;
        }


    </style>
</head>

<body>
    <h1>Population and CO₂ Global Comparison</h1>

    <div id="year-controls">
        
        <div id="slider-wrap">
            Year: <span id="yearValue">1970</span>
            <input type="range" id="yearSlider" min="1970" max="2024" step="1" value="1970">
        </div>

        <span id="mapTitle">Bivariate CO₂ Per Capita vs. Pop. Density Map</span>

        <div></div> <!-- empty spacer for centering -->
    </div>

    

    <div class="container">
        <!-- LEFT SIDE: MAP -->
        <div class="map-pane">
            <div id="map-container">
                <svg id="map"></svg>
            </div>
        </div>

        <!-- RIGHT SIDE: STACKED CHARTS -->
        <div class="charts-pane">
            <div class="chart-box">
                <svg id="chart1"></svg>
            </div>
            <div class="chart-box">
                <svg id="chart2"></svg>
            </div>
        </div>
    </div>

    <div id="bottom-row">
        <div id="legend-container">
            <div id="legend" class="bivariate-legend"></div>
        </div>

        <div id="country-detail">
            <div id="country-title">
                Country Name: <span id="countryName">Click a country on the map</span>
            </div>

            <div id="country-charts">
                <svg id="countryCo2"></svg>
                <svg id="countryPop"></svg>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="opacity:0"></div>

    <script>


        let countriesGeo   = "data/countries.geojson";
        let populationData = "data/population_density_data.csv";
        let co2Data        = "data/co2_capita_data.csv";
        let continentMap   = "data/continentMap.json";
        let totalCO2Data   = "data/total_co2_data.csv";
        let totalPopData = "data/population_data.csv"

        const container = document.getElementById("map-container");
        const width = container.clientWidth;
        const height = container.clientHeight;

        const svg = d3.select("#map")
            .attr("width", width)
            .attr("height", height);

        const g = svg.append("g");

        Promise.all([
            d3.json(countriesGeo),
            d3.csv(populationData),
            d3.csv(co2Data),
            d3.json(continentMap),
            d3.csv(totalCO2Data),
            d3.csv(totalPopData)
        ],
        d3.autoType())
        .then(data => {
            let geoJson        = data[0];
            let popData        = data[1];
            let co2Data        = data[2];
            let continentMapData = data[3];   // <-- renamed for clarity
            let totalCO2Data     = data[4];   // <-- csv with total CO2
            let totalPopData = data[5]



            function getCountrySeries(countryCode) {
                // Find the rows for this country in each dataset
                const popRow = popData.find(d => d["Country Code"] === countryCode);
                const co2Row = co2Data.find(d => d["Country Code"] === countryCode);

                // If we don't find at least one row, bail out
                if (!popRow && !co2Row) return null;

                // Make sure years are numbers (for scales later)
                const years = availableYears.map(y => +y);

                // Build population series (may contain nulls if data missing)
                const popSeries = years.map(y => {
                    const col = String(y);
                    const v = popRow ? +popRow[col] : NaN;
                    return isNaN(v) ? null : v;
                });

                // Build CO₂ per capita series
                const co2Series = years.map(y => {
                    const col = String(y);
                    const v = co2Row ? +co2Row[col] : NaN;
                    return isNaN(v) ? null : v;
                });

                return { years, popSeries, co2Series, popRow, co2Row };
            }



            function updateCountryDetail(countryName, series) {
                const { years, co2Series, popSeries } = series;

                // --- 1. Update title text ---
                d3.select("#countryName").text(countryName);

                // --- 2. Setup SVG references & sizes ---
                const co2Svg = d3.select("#countryCo2");
                const popSvg = d3.select("#countryPop");

                // Use layout-driven sizes (from CSS/flexbox)
                const co2Box = co2Svg.node().getBoundingClientRect();
                const popBox = popSvg.node().getBoundingClientRect();

                const co2Width  = co2Box.width  || 300;
                const co2Height = co2Box.height || 200;
                const popWidth  = popBox.width  || 300;
                const popHeight = popBox.height || 200;

                const margin = { top: 25, right: 15, bottom: 30, left: 45 };

                const innerCo2Width  = co2Width  - margin.left - margin.right;
                const innerCo2Height = co2Height - margin.top  - margin.bottom;
                const innerPopWidth  = popWidth  - margin.left - margin.right;
                const innerPopHeight = popHeight - margin.top  - margin.bottom;

                // Ensure SVG elements have explicit size
                co2Svg.attr("width",  co2Width).attr("height", co2Height);
                popSvg.attr("width",  popWidth).attr("height", popHeight);

                // Clear previous drawings
                co2Svg.selectAll("*").remove();
                popSvg.selectAll("*").remove();

                const co2G = co2Svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                const popG = popSvg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                co2Svg.append("text")
                    .attr("class", "y-axis-label")
                    .attr("x", -co2Height+100)
                    .attr("y", 11)
                    .attr("transform", "rotate(-90)")
                    .attr("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("CO₂ per capita");

                co2Svg.append("text")
                    .attr("class", "x-axis-label")
                    .attr("x", co2Width/2)
                    .attr("y", co2Height-6)
                    .attr("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("Year");


                popSvg.append("text")
                    .attr("class", "y-axis-label")
                    .attr("x", -co2Height+100)
                    .attr("y", 11)
                    .attr("transform", "rotate(-90)")
                    .attr("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("Population density");

                popSvg.append("text")
                    .attr("class", "x-axis-label")
                    .attr("x", co2Width/2)
                    .attr("y", co2Height-6)
                    .attr("text-anchor", "middle")
                    .style("font-size", "11px")
                    .style("font-weight", "bold")
                    .text("Year");

                // --- 3. Build clean data arrays (skip nulls) ---
                const co2DataSeries = years.map((y, i) => ({ Year: y, value: co2Series[i] }))
                    .filter(d => d.value != null);

                const popDataSeries = years.map((y, i) => ({ Year: y, value: popSeries[i] }))
                    .filter(d => d.value != null);

                // If no data at all, show a message and bail out for that chart
                if (co2DataSeries.length === 0) {
                    co2G.append("text")
                        .attr("x", innerCo2Width / 2)
                        .attr("y", innerCo2Height / 2)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .text("No CO₂ data available");
                }

                if (popDataSeries.length === 0) {
                    popG.append("text")
                        .attr("x", innerPopWidth / 2)
                        .attr("y", innerPopHeight / 2)
                        .attr("text-anchor", "middle")
                        .style("font-size", "12px")
                        .text("No population data available");
                }

                // --- 4. Scales ---

                // X domains can still use full year extent (even if some years missing)
                const xCo2 = d3.scaleLinear()
                    .domain(d3.extent(years))
                    .range([0, innerCo2Width]);

                const xPop = d3.scaleLinear()
                    .domain(d3.extent(years))
                    .range([0, innerPopWidth]);

                const yCo2 = d3.scaleLinear()
                    .domain([0, d3.max(co2DataSeries, d => d.value) || 0])
                    .nice()
                    .range([innerCo2Height, 0]);

                const yPop = d3.scaleLinear()
                    .domain([0, d3.max(popDataSeries, d => d.value) || 0])
                    .nice()
                    .range([innerPopHeight, 0]);

                // --- 5. Line generators ---
                const co2Line = d3.line()
                    .defined(d => d.value != null)  // skip gaps
                    .x(d => xCo2(d.Year))
                    .y(d => yCo2(d.value));

                const popLine = d3.line()
                    .defined(d => d.value != null)
                    .x(d => xPop(d.Year))
                    .y(d => yPop(d.value));

                // --- 6. CO₂ chart: axes + line + title ---
                co2G.append("g")
                    .attr("transform", `translate(0,${innerCo2Height})`)
                    .call(d3.axisBottom(xCo2).tickFormat(d3.format("d")).ticks(5));

                co2G.append("g")
                    .call(d3.axisLeft(yCo2));

                if (co2DataSeries.length > 0) {
                    co2G.append("path")
                        .datum(co2DataSeries)
                        .attr("fill", "none")
                        .attr("stroke", "#1f77b4")
                        .attr("stroke-width", 2)
                        .attr("d", co2Line);
                }

                co2G.append("text")
                    .attr("x", innerCo2Width / 2)
                    .attr("y", -8)
                    .attr("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("font-weight", "bold")
                    .text("CO₂ per Capita Line Graph");

                // --- 7. Population chart: axes + line + title ---
                popG.append("g")
                    .attr("transform", `translate(0,${innerPopHeight})`)
                    .call(d3.axisBottom(xPop).tickFormat(d3.format("d")).ticks(5));

                popG.append("g")
                    .call(d3.axisLeft(yPop));

                if (popDataSeries.length > 0) {
                    popG.append("path")
                        .datum(popDataSeries)
                        .attr("fill", "none")
                        .attr("stroke", "#2ca02c")
                        .attr("stroke-width", 2)
                        .attr("d", popLine);
                }

                popG.append("text")
                    .attr("x", innerPopWidth / 2)
                    .attr("y", -8)
                    .attr("text-anchor", "middle")
                    .style("font-size", "14px")
                    .style("font-weight", "bold")
                    .text("Population Density Line Graph");
            }



            const popYearCols = popData.columns.filter(c => /^\d{4}$/.test(c));
            const co2YearCols = co2Data.columns.filter(c => /^\d{4}$/.test(c));


            // 2) Keep only years present in BOTH datasets
            var availableYears = popYearCols.filter(y => co2YearCols.includes(y));
            availableYears = availableYears.filter(item => item !== "2024");

            availableYears = availableYears.filter(item => !item.startsWith("196"));

            console.log(availableYears);

            // 3) Min/max year
            const minYear = "1970"
            const maxYear = d3.max(availableYears, d => +d);
            let selectedYear = String(minYear);

            const yearSlider = d3.select("#yearSlider")
                .attr("min", minYear)
                .attr("max", maxYear)
                .attr("value", selectedYear);

            const yearLabel = d3.select("#yearValue")
                .text(selectedYear);






            const generateWorldMap = (geoJson, containerName, width, height, margin = 30) => {
                // Clear previous map and legend
                g.selectAll("*").remove();
                d3.select("#legend").selectAll("*").remove();

                // 1) Quantiles for current year
                const co2Vals = co2Data
                    .map(d => +d[selectedYear])
                    .filter(v => !isNaN(v));

                const co2Quant = d3.scaleQuantile()
                    .domain(co2Vals.map(v => Math.log10(v + 1)))
                    .range([0, 1, 2]);

                const popVals = popData
                    .map(d => +d[selectedYear])
                    .filter(v => !isNaN(v));

                const popQuant = d3.scaleQuantile()
                    .domain(popVals.map(v => Math.log10(v + 1)))
                    .range([0, 1, 2]);

                function getBivariateKey(co2, pop) {
                    if (co2 == null || pop == null || isNaN(co2) || isNaN(pop)) {
                        return null;
                    }
                    const bin1 = co2Quant(Math.log10(co2 + 1));
                    const bin2 = popQuant(Math.log10(pop + 1));
                    return `${bin1}-${bin2}`;
                }

                console.log("Using year:", selectedYear);
                console.log("pop domain:", popQuant.domain());
                console.log("pop quantiles:", popQuant.quantiles());

                let active = null;

                let countries = [];
                geoJson.features.forEach(d => { countries.push(d.properties["ISO3166-1-Alpha-3"]); });

                let filteredPopData = [];
                popData.forEach(d => {
                    if (countries.includes(d["Country Code"])) {
                        filteredPopData.push(d);
                    }
                });

                let filteredCO2Data = [];
                co2Data.forEach(d => {
                    if (countries.includes(d["Country Code"])) {
                        filteredCO2Data.push(d);
                    }
                });

                const colorScale = d3.scaleOrdinal()
                    .domain(["0-0", "0-1", "0-2", "1-0", "1-1", "1-2", "2-0", "2-1", "2-2"])
                    .range([
                        "#e8e8e8", "#ace4e4", "#5ac8c8",
                        "#dfb0d6", "#a5add3", "#5698b9",
                        "#be64ac", "#8c62aa", "#3b4994"
                    ]);

                const projection = d3.geoMercator().scale(145).translate([width / 2, height / 2 +85]);
                const path = d3.geoPath().projection(projection);
                const tooltip = d3.select("#tooltip");

                g.selectAll("path")
                    .data(geoJson.features)
                    .enter()
                    .append("path")
                    .attr("class", "country")
                    .attr("d", path)
                    .attr("fill", d => {
                        try {
                            let currentCode = d.properties["ISO3166-1-Alpha-3"];
                            let allPopData = filteredPopData.find(i => i["Country Code"] === currentCode);
                            let popVal = allPopData[selectedYear];

                            let allCO2Data = filteredCO2Data.find(i => i["Country Code"] === currentCode);
                            let co2Val = allCO2Data[selectedYear];

                            return colorScale(getBivariateKey(+co2Val, +popVal));
                        } catch (error) {
                            return "gray";
                        }
                    })
                    .on("mouseover", function (event, d) {
                        let currentCode = d.properties["ISO3166-1-Alpha-3"];
                        let allPopData = filteredPopData.find(i => i["Country Code"] === currentCode);
                        let popVal = allPopData ? allPopData[selectedYear] : null;

                        let allCO2Data = filteredCO2Data.find(i => i["Country Code"] === currentCode);
                        let co2Val = allCO2Data ? allCO2Data[selectedYear] : null;

                        const fmt3 = d3.format(",.3f");

                        tooltip.transition().duration(150).style("opacity", 1);
                        tooltip.html(`
                            <strong>${d.properties.name || "Unknown"}</strong><br>
                            Population Density (${selectedYear}): ${popVal ? fmt3(popVal) : "N/A"}<br>
                            CO₂ per Capita (${selectedYear}): ${co2Val ? fmt3(co2Val) : "N/A"}
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");

                        const [cx, cy] = path.centroid(d);

                        d3.select(this)
                            .raise()
                            .transition().duration(150)
                            .style("stroke", "#000")
                            .style("stroke-width", 1.2)
                            .attr("transform",
                                `translate(${cx},${cy}) scale(1.03) translate(${-cx},${-cy})`
                            );
                    })
                    .on("mousemove", (event) => {
                        tooltip.style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function () {
                        tooltip.transition().duration(150).style("opacity", 0);

                        d3.select(this)
                            .transition().duration(150)
                            .style("stroke", "#fff")
                            .style("stroke-width", 0.5)
                            .attr("transform", null);
                    })
                    .on("click", (event, d) => {

                        const co2Svg = d3.select("#countryCo2");
                        const popSvg = d3.select("#countryPop");
                        co2Svg.selectAll("*").remove();
                        popSvg.selectAll("*").remove();

                        d3.select("#countryName").text("Click a country on the map")

                        
                        if (active === d) { 
                            resetZoom(); 
                            active = null; 
                            
                        }
                        else { 
                            zoomToCountry(d); 
                            active = d; 
                            let countryCode = d.properties["ISO3166-1-Alpha-3"];
                            let series = getCountrySeries(countryCode)
                            let countryName = series.co2Row['Country Name'];
                            updateCountryDetail(countryName, series);
                        }
                        event.stopPropagation();
                    });
                


                // Legend
                const legendData = [
                    ["0-2", "1-2", "2-2"],
                    ["0-1", "1-1", "2-1"],
                    ["0-0", "1-0", "2-0"]
                ];

                const legend = d3.select("#legend");

                legend
                    .selectAll(".legend-cell")
                    .data(legendData.flat())
                    .enter()
                    .append("div")
                    .attr("class", "legend-cell")
                    .style("background-color", d => colorScale(d));

                legend.append("div")
                    .attr("class", "legend-axis-label")
                    .style("left", "0px")
                    .style("top", "125px")
                    .text("Higher CO₂ per capita →");

                legend.append("div")
                    .attr("class", "legend-axis-label")
                    .style("position", "absolute")
                    .style("left", "-76px")
                    .style("top", "50px")
                    .style("transform", "rotate(-90deg)")
                    .text("Higher pop. density →");

                const zoom = d3.zoom()
                    .scaleExtent([1, 8])
                    .on("zoom", (event) => { g.attr("transform", event.transform); });

                svg.call(zoom);

                function zoomToCountry(d) {
                    const bounds = path.bounds(d);
                    const dx = bounds[1][0] - bounds[0][0];
                    const dy = bounds[1][1] - bounds[0][1];
                    const padding = 20;

                    let scale = Math.min(8, 0.9 / Math.max(dx / (width - padding), dy / (height - padding)));
                    scale = Math.max(scale, 2);

                    const centroid = d3.geoCentroid(d);
                    const [cx, cy] = projection(centroid);

                    const translateX = width / 2 - scale * cx;
                    const translateY = height / 2 - scale * cy;

                    svg.call(
                        zoom.transform,
                        d3.zoomIdentity
                            .translate(translateX, translateY)
                            .scale(scale)
                    );
                }

                function resetZoom() {
                    svg.call(zoom.transform, d3.zoomIdentity);
                }

                svg.on("click", (event) => {
                    if (event.target.tagName === 'svg') { 
                        resetZoom(); 
                        active = null;

                        const co2Svg = d3.select("#countryCo2");
                        const popSvg = d3.select("#countryPop");
                        co2Svg.selectAll("*").remove();
                        popSvg.selectAll("*").remove();

                        d3.select("#countryName").text("Click a country on the map")

                    }
                });
            };

            generateWorldMap(geoJson, "#map", width, height);

            yearSlider.on("input", function () {
                selectedYear = this.value;
                yearLabel.text(selectedYear);
            });

            yearSlider.on("change", function () {
                selectedYear = this.value;
                yearLabel.text(selectedYear);
                generateWorldMap(geoJson, "#map", width, height);
            });





            
            // ===== STACKED CO2 AREA CHART =====
            const generateCO2Map = (continentMap, totalCO2Data) => {
                // 1) Select the SVG for chart1
                const svgChart = d3.select("#chart1");

                // Clear previous contents (optional, good for re-draws)
                svgChart.selectAll("*").remove();

                // 2) Get the size from the parent .chart-box
                const chartBox = document.getElementById("chart1").parentNode;
                const svgWidth  = chartBox.clientWidth  || 400;
                const svgHeight = chartBox.clientHeight || 250;

                svgChart
                    .attr("width", svgWidth)
                    .attr("height", svgHeight);

                // 3) Margins + inner drawing area
                const margin = { top: 40, right: 130, bottom: 40, left: 70 },
                      innerWidth  = svgWidth  - margin.left - margin.right,
                      innerHeight = svgHeight - margin.top  - margin.bottom;

                const gChart = svgChart.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const tooltip = d3.select(".tooltip");

                // ---- 1. Get list of year columns ----
                const years = totalCO2Data.columns.slice(4);

                // ---- 2. Aggregate by continent ----
                const continentAgg = {};
                totalCO2Data.forEach(d => {
                    const continent = continentMap[d["Country Name"]];
                    if (!continent) return;
                    if (!continentAgg[continent]) continentAgg[continent] = {};
                    years.forEach(y => {
                        const val = parseFloat(d[y]);
                        if (!isNaN(val)) {
                            continentAgg[continent][y] = (continentAgg[continent][y] || 0) + val;
                        }
                    });
                });

                // ---- 3. Convert to array for stacking ----
                const stackedArray = years.map(y => {
                    const row = { Year: +y };
                    Object.keys(continentAgg).forEach(c => {
                        const val = continentAgg[c][y];
                        if (val !== undefined) row[c] = val;
                    });
                    return row;
                }).filter(d => Object.keys(d).length > 1);

                const continents = Object.keys(continentAgg);

                const stack = d3.stack().keys(continents);
                const series = stack(stackedArray);

                // ---- 4. Scales ----
                const x = d3.scaleLinear()
                    .domain(d3.extent(stackedArray, d => d.Year))
                    .range([0, innerWidth]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(series, s => d3.max(s, d => d[1]))])
                    .range([innerHeight, 0]);

                const color = d3.scaleOrdinal(d3.schemeCategory10)
                    .domain(continents);

                // ---- 5. Area generator ----
                const area = d3.area()
                    .x(d => x(d.data.Year))
                    .y0(d => y(d[0]))
                    .y1(d => y(d[1]));

                // ---- 6. Layers ----
                const layers = gChart.selectAll(".layer")
                    .data(series)
                    .join("path")
                    .attr("class", "layer")
                    .attr("d", area)
                    .attr("fill", d => color(d.key))
                    .on("mouseover", function (event, d) {
                        layers.attr("opacity", 0.2);
                        d3.select(this).attr("opacity", 1).raise();
                        tooltip.style("opacity", 1);
                    })
                    .on("mousemove", function (event, d) {
                        const xm = d3.pointer(event, this)[0];
                        const year = Math.round(x.invert(xm));
                        const row = stackedArray.find(r => r.Year === year);
                        if (row && row[d.key] !== undefined) {
                            tooltip
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 25) + "px")
                                .html(`<strong>${d.key}</strong><br>Year: ${year}<br>CO₂: ${row[d.key].toFixed(2)} Mt`);
                        }
                    })
                    .on("mouseout", function () {
                        layers.attr("opacity", 1);
                        tooltip.style("opacity", 0);
                    });

                // ---- 7. Axes ----
                gChart.append("g")
                    .attr("transform", `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(x).tickFormat(d3.format("d")));

                gChart.append("g")
                    .call(d3.axisLeft(y));

                svgChart.append("text")
                    .attr("class", "chart-title")
                    .attr("x", svgWidth / 2)
                    .attr("y", margin.top / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("font-weight", "bold")
                    .text("Global CO₂ Emissions by Continent");

                gChart.append("text")
                    .attr("class", "y-axis-label")
                    .attr("x", -height/5)
                    .attr("y", -45)
                    .attr("transform", "rotate(-90)")
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("CO₂ Emissions");

                gChart.append("text")
                    .attr("class", "x-axis-label")
                    .attr("x", width/4+3)
                    .attr("y", 213)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Year");


                // ---- 8. Legend ----
                const legend = svgChart.append("g")
                    .attr("transform", `translate(${margin.left + innerWidth + 15},${margin.top})`);

                continents.forEach((c, i) => {
                    const gLegend = legend.append("g")
                        .attr("transform", `translate(0,${i * 18})`);

                    gLegend.append("rect")
                        .attr("width", 14)
                        .attr("height", 14)
                        .attr("fill", color(c));

                    gLegend.append("text")
                        .attr("x", 20)
                        .attr("y", 11)
                        .attr("font-size", 13)
                        .text(c);
                });
            };

            // draw stacked CO2 chart once
            generateCO2Map(continentMapData, totalCO2Data);




            // ==== STACKED POPULATION AREA CHART IN #chart2 ====
            const generatePopMap = (continentMap, totalPopData) => {
                // 1) Select the SVG for chart2
                const svgChart = d3.select("#chart2");

                // Clear previous contents (good if you ever re-draw)
                svgChart.selectAll("*").remove();

                // 2) Get the size from the parent .chart-box
                const chartBox = document.getElementById("chart2").parentNode;
                const svgWidth  = chartBox.clientWidth  || 400;
                const svgHeight = chartBox.clientHeight || 250;

                svgChart
                    .attr("width", svgWidth)
                    .attr("height", svgHeight);

                // 3) Margins + inner drawing area
                const margin = { top: 40, right: 130, bottom: 40, left: 70 },
                    innerWidth  = svgWidth  - margin.left - margin.right,
                    innerHeight = svgHeight - margin.top  - margin.bottom;

                const gChart = svgChart.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const tooltip = d3.select(".tooltip");

                // ---- 1. Get list of year columns ----
                const years = totalPopData.columns.slice(4);  // assumes same structure as CO2 CSV

                // ---- 2. Aggregate population by continent ----
                const continentAgg = {};
                totalPopData.forEach(d => {
                    const continent = continentMap[d["Country Name"]];
                    if (!continent) return;
                    if (!continentAgg[continent]) continentAgg[continent] = {};
                    years.forEach(y => {
                        const val = parseFloat(d[y]);
                        if (!isNaN(val)) {
                            continentAgg[continent][y] = (continentAgg[continent][y] || 0) + val;
                        }
                    });
                });

                // ---- 3. Convert to array for stacking ----
                const stackedArray = years.map(y => {
                    const row = { Year: +y };
                    Object.keys(continentAgg).forEach(c => {
                        const val = continentAgg[c][y];
                        if (val !== undefined) row[c] = val;
                    });
                    return row;
                }).filter(d => Object.keys(d).length > 1);

                const continents = Object.keys(continentAgg);

                const stack = d3.stack().keys(continents);
                const series = stack(stackedArray);

                // ---- 4. Scales ----
                const x = d3.scaleLinear()
                    .domain(d3.extent(stackedArray, d => d.Year))
                    .range([0, innerWidth]);

                const y = d3.scaleLinear()
                    .domain([0, d3.max(series, s => d3.max(s, d => d[1]))])
                    .range([innerHeight, 0]);

                const color = d3.scaleOrdinal(d3.schemeCategory10)
                    .domain(continents);

                // ---- 5. Area generator ----
                const area = d3.area()
                    .x(d => x(d.data.Year))
                    .y0(d => y(d[0]))
                    .y1(d => y(d[1]));

                // ---- 6. Layers ----
                const layers = gChart.selectAll(".layer")
                    .data(series)
                    .join("path")
                    .attr("class", "layer")
                    .attr("d", area)
                    .attr("fill", d => color(d.key))
                    .on("mouseover", function (event, d) {
                        layers.attr("opacity", 0.2);
                        d3.select(this).attr("opacity", 1).raise();
                        tooltip.style("opacity", 1);
                    })
                    .on("mousemove", function (event, d) {
                        const xm = d3.pointer(event, this)[0];
                        const year = Math.round(x.invert(xm));
                        const row = stackedArray.find(r => r.Year === year);
                        if (row && row[d.key] !== undefined) {
                            tooltip
                                .style("left", (event.pageX + 10) + "px")
                                .style("top",  (event.pageY - 25) + "px")
                                .html(
                                    `<strong>${d.key}</strong><br>` +
                                    `Year: ${year}<br>` +
                                    `Population: ${d3.format(",")(row[d.key])}`
                                );
                        }
                    })
                    .on("mouseout", function () {
                        layers.attr("opacity", 1);
                        tooltip.style("opacity", 0);
                    });


                svgChart.append("text")
                    .attr("class", "chart-title")
                    .attr("x", svgWidth / 2)
                    .attr("y", margin.top / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "18px")
                    .style("font-weight", "bold")
                    .text("Global Population by Continent");
                
                // ---- 7. Axes ----
                gChart.append("g")
                    .attr("transform", `translate(0,${innerHeight})`)
                    .call(d3.axisBottom(x).tickFormat(d3.format("d")));

                gChart.append("g")
                    .call(d3.axisLeft(y).tickFormat(d3.format(".2s"))); // nice compact 1M, 10M, etc.
                
                
                gChart.append("text")
                    .attr("class", "y-axis-label")
                    .attr("x", -height/5)
                    .attr("y", -45)
                    .attr("transform", "rotate(-90)")
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Population");

                gChart.append("text")
                    .attr("class", "x-axis-label")
                    .attr("x", width/4+3)
                    .attr("y", 213)
                    .attr("text-anchor", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold")
                    .text("Year");

                // ---- 8. Legend ----
                const legend = svgChart.append("g")
                    .attr("transform", `translate(${margin.left + innerWidth + 15},${margin.top})`);

                continents.forEach((c, i) => {
                    const gLegend = legend.append("g")
                        .attr("transform", `translate(0,${i * 18})`);

                    gLegend.append("rect")
                        .attr("width", 14)
                        .attr("height", 14)
                        .attr("fill", color(c));

                    gLegend.append("text")
                        .attr("x", 20)
                        .attr("y", 11)
                        .attr("font-size", 13)
                        .text(c);
                });
            };


            generatePopMap(continentMapData, totalPopData);
























        });
    </script>
</body>
</html>
